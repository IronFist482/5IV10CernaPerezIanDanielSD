import { ANTLRInputStream, CommonTokenStream, Token, RuleContext } from 'antlr4ts';
import { MySQLParserListener } from './grammar/MySQLParserListener';
import { MySQLParser } from './grammar/MySQLParser';
import { MySQLLexer } from './grammar/MySQLLexer';
import { Reference, FunctionReference, KeywordReference, ColumnReference, TableReference, AliasReference, ValueReference } from './listeners/parser-listener';
import { ParserErrorListener } from './listeners/parser-error-listener';
import { LexerErrorListener } from './listeners/lexer-error-listener';
import { LexerError, ParserError } from './listeners/errors';
import { MySQLQueryType } from './lib/parsers-common';
import { SqlMode } from './grammar/common';
import { RuleName } from './lib/rule-name';
/** Statement represents a single MySQL query */
export interface Statement {
    /** The text of the statement */
    text: string;
    /** The zero-based offset of the starting position of the statement in the original text */
    start: number;
    /** The zero-based offset of the stopping position of the statement in the original text */
    stop: number;
}
/** ParseResult represents all relevant results of parsing a query */
export interface ParseResult {
    /** The listener during the parsing phase */
    parserListener: MySQLParserListener;
    /** The error that occurred during the parsing phase */
    parserError?: ParserError;
    /** The error that ocurrred during the lexing phase */
    lexerError?: LexerError;
    /** The token stream that was fed into the parser */
    tokenStream: CommonTokenStream;
    /** The input stream that was fed into the lexer */
    inputStream: ANTLRInputStream;
    /** The generated MySQL parser */
    parser: MySQLParser;
    /** The generated MySQL lexer */
    lexer: MySQLLexer;
    /** The parse tree */
    tree: RuleContext;
    /** The references found during parsing (e.g. tables, columns, etc.) */
    references: References;
}
export interface References {
    functionReferences: FunctionReference[];
    keywordReferences: KeywordReference[];
    columnReferences: ColumnReference[];
    tableReferences: TableReference[];
    aliasReferences: AliasReference[];
    valueReferences: ValueReference[];
}
/** ParserOptions represents the options passed into the parser */
export interface ParserOptions {
    /** Custom parser error listener */
    readonly parserErrorListener?: ParserErrorListener;
    /** Custom lexer error listener */
    readonly lexerErrorListener?: LexerErrorListener;
    /** Custom parser listener */
    readonly parserListener?: MySQLParserListener;
    readonly charsets?: string[];
    readonly version?: string;
    readonly mode?: SqlMode;
}
export default class Parser {
    parserErrorListener?: ParserErrorListener;
    lexerErrorListener?: LexerErrorListener;
    parserListener?: MySQLParserListener;
    charsets: string[];
    version: string;
    mode: SqlMode;
    constructor(options?: ParserOptions);
    /**
     * Parse the given MySQL query. Execution order:
     *
     *  1. Initialize streams and lexer/parser
     *  2. Remove error listeners
     *  3. Set MySQL version/mode/charsets in the parser and lexer
     *  4. Prepare listeners
     *  5. Parse query in two-stage process
     *  6. Resolve references found during parse
     *  7. Return relevant parsing results
     *
     * @param query - the query to parse
     * @param context - the optional rule context to invoke. defaults to `.query()`
     * @returns ParseResult
     */
    parse(query: string, context?: RuleName): ParseResult;
    /**
     * Get the node at the given offset in the source text.
     *
     * @param parseResult
     * @param offset
     * @returns Reference | null
     */
    getNodeAtOffset(parseResult: ParseResult, offset: number): Reference | null;
    getTokenAtOffset(parseResult: ParseResult, offset: number): Token | null;
    getReferenceAtOffset(parseResult: ParseResult, offset: number): Reference | null;
    /**
     * Split a text of MySQL queries into multiple statements, optionally specifying the line break and delimiter.
     *
     * @param text
     * @param lineBreak
     * @param delimiter
     * @returns Statement[]
     */
    splitStatements(text: string, lineBreak?: string, delimiter?: string): Statement[];
    /**
     * Get the statement given by the offset.
     *
     * @param statements
     * @param offset
     * @returns Statement | null
     */
    getStatementAtOffset(statements: Statement[], offset: number): Statement | null;
    /**
     * Check if the provided text is a MySQL keyword.
     *
     * @param text
     * @returns boolean
     */
    isKeyword(text: string): boolean;
    /**
     * Check if the provided text is a MySQL reserved keyword.
     *
     * @param text
     * @returns boolean
     */
    isReservedKeyword(text: string): boolean;
    /**
     * Get all MySQL keywords.
     *
     * @returns string[]
     */
    getKeywords(): string[];
    /**
     * Get all MySQL reserved keywords.
     *
     * @returns string[]
     */
    getReservedKeywords(): string[];
    /**
     * Check if the given parse result represents a DDL statement.
     *
     * @param {parseResult}
     * @returns boolean
     */
    isDDL(parseResult: ParseResult): boolean;
    /**
     * Get the type of query given by the parse result.
     *
     * @param {parseResult}
     * @returns MySQLQueryType
     */
    getQueryType(parseResult: ParseResult): MySQLQueryType;
    /**
     * Check if the given `type` represents an identifier.
     *
     * @param {parseResult}
     * @param {type}
     * @returns boolean
     */
    isIdentifier(parseResult: ParseResult, type: number): boolean;
}
