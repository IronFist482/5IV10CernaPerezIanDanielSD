"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const antlr4ts_1 = require("antlr4ts");
const MySQLLexer_1 = require("./MySQLLexer");
const Lexer_1 = require("antlr4ts/Lexer");
const common_1 = require("./common");
// This is a superclass used to customize lexer functionality.
class MySQLBaseLexer extends Lexer_1.Lexer {
    constructor(input) {
        super(input);
        this.inVersionComment = false;
        this.serverVersion = 50707;
        this.pendingTokens = [];
        this.charsets = [];
    }
    reset() {
        this.inVersionComment = false;
        super.reset();
    }
    // Allow a grammar rule to emit as many tokens as it needs.
    nextToken() {
        // First respond with pending tokens to the next token request, if there are any.
        if (this.pendingTokens.length > 0) {
            const pending = this.pendingTokens.shift();
            if (pending) {
                return pending;
            }
        }
        // Let the main lexer class run the next token recognition.
        // This might create additional tokens again.
        const next = super.nextToken();
        if (this.pendingTokens.length > 0) {
            const pending = this.pendingTokens.shift();
            this.pendingTokens.push(next);
            if (pending) {
                return pending;
            }
        }
        return next;
    }
    nextDefaultChannelToken() {
        let token = this.nextToken();
        while (token.channel !== antlr4ts_1.Token.DEFAULT_CHANNEL) {
            token = this.nextToken();
        }
        return token;
    }
    emitDot() {
        const token = this.tokenFactory.create(this._tokenFactorySourcePair, MySQLLexer_1.MySQLLexer.DOT_SYMBOL, '.', this._channel, this._tokenStartCharIndex, this._tokenStartCharIndex, this._tokenStartLine, this._tokenStartCharPositionInLine);
        this.pendingTokens.push(token);
        ++this._tokenStartCharIndex;
    }
    checkVersion(text) {
        // Minimum is: /*!12345
        if (text.length < 8) {
            return false;
        }
        // Skip version comment introducer.
        const version = parseInt(text.substring(3, text.length), 10);
        if (version <= this.serverVersion) {
            this.inVersionComment = true;
            return true;
        }
        return false;
    }
    checkCharset(text) {
        return this.charsets.includes(text) ? MySQLLexer_1.MySQLLexer.UNDERSCORE_CHARSET : MySQLLexer_1.MySQLLexer.IDENTIFIER;
    }
    // Returns true if the given mode (one of the enums above) is set.
    isSqlModeActive(mode) {
        if (!this.sqlMode) {
            return false;
        }
        return (this.sqlMode & mode) !== 0;
    }
    determineFunction(proposed) {
        // Skip any whitespace character if the sql mode says they should be ignored,
        // before actually trying to match the open parenthesis.
        if (this.isSqlModeActive(common_1.SqlMode.IgnoreSpace)) {
            let input = this._input.LA(1);
            let character = String.fromCharCode(input);
            while (character === ' ' || character === '\t' || character === '\r' || character === '\n') {
                this.interpreter.consume(this._input);
                this.channel = Lexer_1.Lexer.HIDDEN;
                this.type = MySQLLexer_1.MySQLLexer.WHITESPACE;
                input = this._input.LA(1);
                character = String.fromCharCode(input);
            }
        }
        const input = this._input.LA(1);
        return String.fromCharCode(input) === '(' ? proposed : MySQLLexer_1.MySQLLexer.IDENTIFIER;
    }
}
exports.MySQLBaseLexer = MySQLBaseLexer;
//# sourceMappingURL=MySQLBaseLexer.js.map