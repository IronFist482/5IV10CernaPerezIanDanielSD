"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MySQLParser_1 = require("../grammar/MySQLParser");
const unquote_1 = require("../lib/unquote");
const antlr4ts_1 = require("antlr4ts");
var ReferenceType;
(function (ReferenceType) {
    ReferenceType["FunctionRef"] = "FunctionRef";
    ReferenceType["KeywordRef"] = "KeywordRef";
    ReferenceType["ColumnRef"] = "ColumnRef";
    ReferenceType["SchemaRef"] = "SchemaRef";
    ReferenceType["TableRef"] = "TableRef";
    ReferenceType["AliasRef"] = "AliasRef";
    ReferenceType["ValueRef"] = "ValueRef";
})(ReferenceType = exports.ReferenceType || (exports.ReferenceType = {}));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getParentRule(ctx, parentRule) {
    if (ctx instanceof parentRule) {
        return ctx;
    }
    const parent = ctx.parent;
    if (parent) {
        return getParentRule(parent, parentRule);
    }
    return null;
}
function getReferenceContext(ctx) {
    const whereClauseContext = getParentRule(ctx, MySQLParser_1.WhereClauseContext);
    if (whereClauseContext) {
        return 'whereClause';
    }
    const valuesClauseContext = getParentRule(ctx, MySQLParser_1.ValuesContext);
    if (valuesClauseContext) {
        return 'valuesClause';
    }
    const fieldsClauseContext = getParentRule(ctx, MySQLParser_1.FieldsContext);
    if (fieldsClauseContext) {
        return 'fieldsClause';
    }
    return null;
}
function getNestedColumnRef(ctx) {
    if (ctx instanceof MySQLParser_1.ColumnRefContext) {
        return ctx;
    }
    for (let i = 0; i < ctx.childCount; i++) {
        const child = ctx.getChild(i);
        if (child instanceof antlr4ts_1.RuleContext) {
            return getNestedColumnRef(child);
        }
    }
    return null;
}
function getDataType(predicate) {
    var _a, _b;
    const literalContext = (_b = (_a = predicate
        .tryGetChild(0, MySQLParser_1.BitExprContext)) === null || _a === void 0 ? void 0 : _a.tryGetChild(0, MySQLParser_1.SimpleExprLiteralContext)) === null || _b === void 0 ? void 0 : _b.literal().children;
    if (literalContext) {
        const literal = literalContext[0];
        switch (true) {
            case literal instanceof MySQLParser_1.TextLiteralContext:
                return 'string';
            case literal instanceof MySQLParser_1.NumLiteralContext:
                return 'number';
            case literal instanceof MySQLParser_1.BoolLiteralContext:
                return 'boolean';
            case literal instanceof MySQLParser_1.TemporalLiteralContext:
                return 'date';
            case literal instanceof MySQLParser_1.NullLiteralContext:
                return 'null';
        }
    }
    return null;
}
// Covers scenarios like top-level columns in WHERE clauses of JOINs + columns in ORDER BY
function getTableRefContext(ctx) {
    var _a, _b, _c, _d, _e;
    const queryExpressionBody = getParentRule(ctx, MySQLParser_1.QueryExpressionBodyContext);
    const queryExpression = getParentRule(ctx, MySQLParser_1.QueryExpressionContext);
    const context = queryExpressionBody !== null && queryExpressionBody !== void 0 ? queryExpressionBody : queryExpression === null || queryExpression === void 0 ? void 0 : queryExpression.queryExpressionBody();
    const tableRefContext = (_e = (_d = (_c = (_b = (_a = context === null || context === void 0 ? void 0 : context.querySpecification()) === null || _a === void 0 ? void 0 : _a.fromClause()) === null || _b === void 0 ? void 0 : _b.tableReferenceList()) === null || _c === void 0 ? void 0 : _c.tableReference()[0].tableFactor()) === null || _d === void 0 ? void 0 : _d.singleTable()) === null || _e === void 0 ? void 0 : _e.tableRef();
    return tableRefContext !== null && tableRefContext !== void 0 ? tableRefContext : null;
}
function getTableReference(ctx) {
    var _a;
    if (ctx === null) {
        return null;
    }
    const qualifierIdentifier = ctx.qualifiedIdentifier();
    if (qualifierIdentifier) {
        const identifier = qualifierIdentifier.identifier();
        const first = unquote_1.unquote(identifier.text);
        const start = identifier.start.startIndex;
        const stop = identifier.start.stopIndex;
        const dotIdentifier = qualifierIdentifier.dotIdentifier();
        if (dotIdentifier) {
            return {
                type: ReferenceType.TableRef,
                table: unquote_1.unquote(dotIdentifier.identifier().text),
                aliasReference: null,
                schemaReference: {
                    type: ReferenceType.SchemaRef,
                    schema: first,
                    start,
                    stop
                },
                start: dotIdentifier.identifier().start.startIndex,
                stop: dotIdentifier.identifier().start.stopIndex
            };
        }
        return {
            type: ReferenceType.TableRef,
            aliasReference: null,
            schemaReference: null,
            table: first,
            start: identifier.start.startIndex,
            stop: identifier.start.stopIndex
        };
    }
    const identifier = (_a = ctx.dotIdentifier()) === null || _a === void 0 ? void 0 : _a.identifier();
    if (identifier) {
        return {
            type: ReferenceType.TableRef,
            aliasReference: null,
            schemaReference: null,
            table: unquote_1.unquote(identifier.text),
            start: identifier.start.startIndex,
            stop: identifier.start.stopIndex
        };
    }
    return null;
}
function getParentTableReference(ctx) {
    const tableRefContext = getTableRefContext(ctx);
    if (!tableRefContext) {
        return null;
    }
    return getTableReference(tableRefContext);
}
function getColumnReference(ctx) {
    var _a;
    if (ctx === null) {
        return null;
    }
    const context = ctx.fieldIdentifier();
    const qualifierIdentifier = context.qualifiedIdentifier();
    if (qualifierIdentifier) {
        const identifier = qualifierIdentifier.identifier();
        const first = unquote_1.unquote(identifier.text);
        const start = identifier.start.startIndex;
        const stop = identifier.start.stopIndex;
        const dotIdentifier = qualifierIdentifier.dotIdentifier();
        if (dotIdentifier) {
            return {
                type: ReferenceType.ColumnRef,
                context: getReferenceContext(ctx),
                column: unquote_1.unquote(dotIdentifier.identifier().text),
                aliasReference: null,
                tableReference: {
                    type: ReferenceType.TableRef,
                    aliasReference: null,
                    schemaReference: null,
                    table: first,
                    start,
                    stop
                },
                start: dotIdentifier.identifier().start.startIndex,
                stop: dotIdentifier.identifier().start.stopIndex
            };
        }
        return {
            type: ReferenceType.ColumnRef,
            column: first,
            context: getReferenceContext(ctx),
            aliasReference: null,
            tableReference: getParentTableReference(context),
            start,
            stop
        };
    }
    const identifier = (_a = context.dotIdentifier()) === null || _a === void 0 ? void 0 : _a.identifier();
    if (identifier) {
        return {
            type: ReferenceType.ColumnRef,
            column: unquote_1.unquote(identifier.text),
            context: getReferenceContext(ctx),
            aliasReference: null,
            tableReference: getParentTableReference(context),
            start: identifier.start.startIndex,
            stop: identifier.start.stopIndex
        };
    }
    return null;
}
function getParentColumnRef(ctx) {
    const parent = ctx.parent;
    if (parent instanceof MySQLParser_1.PrimaryExprCompareContext) {
        const columnRef = getNestedColumnRef(parent.boolPri());
        return columnRef;
    }
    if (parent instanceof MySQLParser_1.PrimaryExprPredicateContext) {
        const columnRef = getNestedColumnRef(parent.predicate());
        return columnRef;
    }
    return null;
}
class ParserListener {
    constructor() {
        this.functionReferences = [];
        this.keywordReferences = [];
        this.columnReferences = [];
        this.tableReferences = [];
        this.aliasReferences = [];
        this.valueReferences = [];
    }
    exitColumnRef(ctx) {
        const reference = getColumnReference(ctx);
        if (!reference) {
            return;
        }
        this.columnReferences.push(reference);
    }
    exitTableRef(ctx) {
        const reference = getTableReference(ctx);
        if (!reference) {
            return;
        }
        this.tableReferences.push(reference);
    }
    exitTableAlias(ctx) {
        if (!ctx.parent) {
            return;
        }
        const siblingCount = ctx.parent.childCount;
        if (siblingCount < 1) {
            return;
        }
        const tableChild = ctx.parent.tryGetChild(0, MySQLParser_1.TableRefContext);
        if (!tableChild) {
            return;
        }
        const tableReference = {
            type: ReferenceType.TableRef,
            aliasReference: null,
            schemaReference: null,
            table: unquote_1.unquote(tableChild.text),
            start: tableChild.start.startIndex,
            stop: tableChild.start.stopIndex
        };
        const aliasChild = ctx.tryGetChild(0, MySQLParser_1.IdentifierContext);
        if (!aliasChild) {
            return;
        }
        const aliasReference = {
            type: ReferenceType.AliasRef,
            columnReference: null,
            tableReference,
            alias: unquote_1.unquote(aliasChild.text),
            start: aliasChild.start.startIndex,
            stop: aliasChild.start.stopIndex
        };
        this.aliasReferences.push(aliasReference);
    }
    exitSelectAlias(ctx) {
        if (!ctx.parent) {
            return;
        }
        const predicate = ctx.parent
            .getChild(0)
            .getChild(0)
            .getChild(0);
        if (!predicate) {
            return;
        }
        const columnRef = getParentColumnRef(predicate);
        const aliasChild = ctx.tryGetChild(0, MySQLParser_1.IdentifierContext);
        if (!aliasChild) {
            return;
        }
        const aliasReference = {
            type: ReferenceType.AliasRef,
            columnReference: getColumnReference(columnRef),
            tableReference: null,
            alias: unquote_1.unquote(aliasChild.text),
            start: aliasChild.start.startIndex,
            stop: aliasChild.start.stopIndex
        };
        this.aliasReferences.push(aliasReference);
    }
    exitPredicate(ctx) {
        const dataType = getDataType(ctx);
        if (!dataType) {
            return;
        }
        const columnRef = getParentColumnRef(ctx);
        const valueReference = {
            type: ReferenceType.ValueRef,
            context: getReferenceContext(ctx),
            columnReference: getColumnReference(columnRef),
            dataType,
            value: unquote_1.unquote(ctx.text),
            start: ctx.start.startIndex,
            stop: ctx.start.stopIndex
        };
        this.valueReferences.push(valueReference);
    }
    exitFunctionCall(ctx) {
        const context = ctx.pureIdentifier();
        if (!context) {
            return;
        }
        this.functionReferences.push({
            type: ReferenceType.FunctionRef,
            function: unquote_1.unquote(context.text),
            start: context.start.startIndex,
            stop: context.start.stopIndex
        });
    }
    exitSubquery() {
        // ... TODO: figure out how to reset for subqueries
    }
    exitEveryRule() {
        // noop
    }
}
exports.ParserListener = ParserListener;
//# sourceMappingURL=parser-listener.js.map