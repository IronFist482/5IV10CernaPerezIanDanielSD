"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const antlr4ts_1 = require("antlr4ts");
const errors_1 = require("./errors");
const interval_to_array_1 = require("../lib/interval-to-array");
function getErrorMessage(error, message, expectedTokens, offendingToken) {
    let wrongText = offendingToken.text || '';
    if (!wrongText.startsWith('"') && !wrongText.startsWith("'") && !wrongText.startsWith('`')) {
        wrongText = '"' + wrongText + '"';
    }
    // only show 6 tokens in error message
    const expectedText = expectedTokens.slice(0, 5).join(', ');
    const isEof = offendingToken.type === antlr4ts_1.Token.EOF;
    if (!error) {
        if (message.includes('missing') && expectedTokens.length === 1) {
            return `Missing ${expectedText}`;
        }
        else {
            return `Extraneous input ${wrongText} found, expecting ${expectedText}`;
        }
    }
    else {
        if (error instanceof antlr4ts_1.InputMismatchException || error instanceof antlr4ts_1.NoViableAltException) {
            if (isEof) {
                return 'Statement is incomplete';
            }
            else {
                return `${wrongText} is not valid at this position`;
            }
        }
        if (error instanceof antlr4ts_1.FailedPredicateException) {
            // TODO
        }
    }
    return message;
}
class ParserErrorListener {
    syntaxError(recognizer, offendingToken, line, character, message, error) {
        // offendingToken is only undefined for lexer error listeners, so its safe to return here
        if (!offendingToken) {
            return;
        }
        const expected = recognizer.atn.getExpectedTokens(recognizer.state, error === null || error === void 0 ? void 0 : error.context);
        const expectedTokens = interval_to_array_1.intervalToArray(expected, recognizer.vocabulary);
        const errorMessage = getErrorMessage(error, message, expectedTokens, offendingToken);
        this.error = new errors_1.ParserError(errorMessage, {
            offendingToken: offendingToken !== null && offendingToken !== void 0 ? offendingToken : null,
            expectedTokens,
            character,
            line
        });
    }
}
exports.ParserErrorListener = ParserErrorListener;
//# sourceMappingURL=parser-error-listener.js.map