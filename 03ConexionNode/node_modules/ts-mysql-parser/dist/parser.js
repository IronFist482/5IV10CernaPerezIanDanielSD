"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const antlr4ts_1 = require("antlr4ts");
const MySQLParser_1 = require("./grammar/MySQLParser");
const MySQLLexer_1 = require("./grammar/MySQLLexer");
const parser_listener_1 = require("./listeners/parser-listener");
const parser_error_listener_1 = require("./listeners/parser-error-listener");
const lexer_error_listener_1 = require("./listeners/lexer-error-listener");
const version_1 = require("./lib/version");
const resolve_references_1 = require("./lib/resolve-references");
const skip_leading_whitespace_1 = require("./lib/skip-leading-whitespace");
const parsers_common_1 = require("./lib/parsers-common");
const PredictionMode_1 = require("antlr4ts/atn/PredictionMode");
const common_1 = require("./grammar/common");
const rule_name_1 = require("./lib/rule-name");
class Parser {
    constructor(options = {}) {
        this.parserErrorListener = options.parserErrorListener;
        this.lexerErrorListener = options.lexerErrorListener;
        this.parserListener = options.parserListener;
        this.mode = options.mode || common_1.SqlMode.NoMode;
        this.version = options.version || '5.7.7';
        this.charsets = options.charsets || [];
    }
    /**
     * Parse the given MySQL query. Execution order:
     *
     *  1. Initialize streams and lexer/parser
     *  2. Remove error listeners
     *  3. Set MySQL version/mode/charsets in the parser and lexer
     *  4. Prepare listeners
     *  5. Parse query in two-stage process
     *  6. Resolve references found during parse
     *  7. Return relevant parsing results
     *
     * @param query - the query to parse
     * @param context - the optional rule context to invoke. defaults to `.query()`
     * @returns ParseResult
     */
    parse(query, context = rule_name_1.RuleName.query) {
        const inputStream = new antlr4ts_1.ANTLRInputStream(query);
        const lexer = new MySQLLexer_1.MySQLLexer(inputStream);
        const tokenStream = new antlr4ts_1.CommonTokenStream(lexer);
        const parser = new MySQLParser_1.MySQLParser(tokenStream);
        // remove antlr default error listeners
        lexer.removeErrorListeners();
        parser.removeErrorListeners();
        // set MySQL version
        const version = version_1.versionToNumber(this.version);
        parser.serverVersion = version;
        lexer.serverVersion = version;
        // set MySQL mode
        parser.sqlMode = this.mode;
        lexer.sqlMode = this.mode;
        // set MySQL charsets
        lexer.charsets = this.charsets;
        // prepare parser error listener
        const parserErrorListener = this.parserErrorListener || new parser_error_listener_1.ParserErrorListener();
        parser.addErrorListener(parserErrorListener);
        // prepare lexer error listener
        const lexerErrorListener = this.lexerErrorListener || new lexer_error_listener_1.LexerErrorListener(lexer);
        lexer.addErrorListener(lexerErrorListener);
        // prepare parse listener
        const parserListener = this.parserListener || new parser_listener_1.ParserListener();
        parser.addParseListener(parserListener);
        // two-step parsing process
        //    step 1: attempt SLL that almost always works and is fast
        //    step 2: if step 1 fails, use full LL parse to ensure we have a real failure
        parser.interpreter.setPredictionMode(PredictionMode_1.PredictionMode.SLL);
        parser.errorHandler = new antlr4ts_1.BailErrorStrategy();
        let tree;
        try {
            tree = parser[context]();
        }
        catch (e) {
            inputStream.reset();
            lexerErrorListener.error = undefined;
            parserErrorListener.error = undefined;
            parser.errorHandler = new antlr4ts_1.DefaultErrorStrategy();
            parser.interpreter.setPredictionMode(PredictionMode_1.PredictionMode.LL);
            tree = parser[context]();
        }
        const references = {
            functionReferences: [],
            keywordReferences: [],
            columnReferences: [],
            tableReferences: [],
            aliasReferences: [],
            valueReferences: []
        };
        if (parserListener instanceof parser_listener_1.ParserListener) {
            const { functionReferences, keywordReferences, columnReferences, tableReferences, aliasReferences, valueReferences } = parserListener;
            references.functionReferences = functionReferences;
            references.keywordReferences = keywordReferences;
            references.columnReferences = resolve_references_1.resolveColumns(columnReferences, tableReferences);
            references.tableReferences = tableReferences;
            references.aliasReferences = aliasReferences;
            references.valueReferences = resolve_references_1.resolveValues(valueReferences, tableReferences, columnReferences);
        }
        return {
            parserError: parserErrorListener.error,
            lexerError: lexerErrorListener.error,
            parserListener,
            tokenStream,
            inputStream,
            references,
            parser,
            lexer,
            tree
        };
    }
    /**
     * Get the node at the given offset in the source text.
     *
     * @param parseResult
     * @param offset
     * @returns Reference | null
     */
    getNodeAtOffset(parseResult, offset) {
        const reference = this.getReferenceAtOffset(parseResult, offset);
        if (reference) {
            return reference;
        }
        // note: it may be better to do this in the parse listener
        const token = this.getTokenAtOffset(parseResult, offset);
        // TODO: check the token type
        if (token && token.text) {
            if (this.isReservedKeyword(token.text)) {
                return {
                    type: parser_listener_1.ReferenceType.KeywordRef,
                    keyword: token.text,
                    start: token.startIndex,
                    stop: token.stopIndex
                };
            }
        }
        return null;
    }
    getTokenAtOffset(parseResult, offset) {
        parseResult.lexer.reset();
        const tokens = parseResult.lexer.getAllTokens();
        let found = null;
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            if (offset >= token.startIndex && offset <= token.stopIndex) {
                found = token;
                break;
            }
        }
        return found;
    }
    getReferenceAtOffset(parseResult, offset) {
        let found = null;
        const { functionReferences, keywordReferences, columnReferences, tableReferences, aliasReferences, valueReferences } = parseResult.references;
        const references = [
            ...functionReferences,
            ...keywordReferences,
            ...columnReferences,
            ...tableReferences,
            ...aliasReferences,
            ...valueReferences
        ];
        for (const reference of references) {
            if (offset >= reference.start && offset <= reference.stop) {
                found = reference;
                break;
            }
        }
        return found;
    }
    /**
     * Split a text of MySQL queries into multiple statements, optionally specifying the line break and delimiter.
     *
     * @param text
     * @param lineBreak
     * @param delimiter
     * @returns Statement[]
     */
    splitStatements(text, lineBreak, delimiter) {
        lineBreak = lineBreak || '\n';
        delimiter = delimiter || ';';
        const statements = [];
        let delimiterHead = delimiter[0];
        const keywordPos = 0;
        const start = 0;
        let head = start;
        let tail = head;
        const end = head + text.length;
        // Set when anything else but comments were found for the current statement.
        let haveContent = false;
        while (tail < end) {
            switch (text[tail]) {
                // Possible multi line comment or hidden (conditional) command.
                case '/': {
                    if (text[tail + 1] === '*') {
                        tail += 2;
                        const isHiddenCommand = text[tail] === '!';
                        // eslint-disable-next-line no-constant-condition
                        while (true) {
                            while (tail < end && text[tail] !== '*') {
                                tail++;
                            }
                            // Unfinished comment.
                            if (tail === end) {
                                break;
                            }
                            else {
                                if (text[++tail] === '/') {
                                    // Skip the slash too.
                                    tail++;
                                    break;
                                }
                            }
                        }
                        if (isHiddenCommand) {
                            haveContent = true;
                        }
                        if (!haveContent) {
                            // Skip over the comment.
                            head = tail;
                        }
                    }
                    else {
                        tail++;
                    }
                    break;
                }
                // Possible single line comment.
                case '-': {
                    const endChar = tail + 2;
                    if (text[tail + 1] === '-' &&
                        (text[endChar] === ' ' || text[endChar] === '\t' || text[endChar] === lineBreak)) {
                        // Skip everything until the end of the line.
                        tail += 2;
                        while (tail < end && text[tail] !== lineBreak) {
                            tail++;
                        }
                        if (!haveContent) {
                            head = tail;
                        }
                    }
                    else {
                        tail++;
                    }
                    break;
                }
                // MySQL single line comment.
                case '#': {
                    while (tail < end && text[tail] !== lineBreak) {
                        tail++;
                    }
                    if (!haveContent) {
                        head = tail;
                    }
                    break;
                }
                case '"':
                case "'":
                case '`': {
                    haveContent = true;
                    const quote = text[tail++];
                    while (tail < end && text[tail] !== quote) {
                        // Skip any escaped character too.
                        if (text[tail] === '\\') {
                            tail++;
                        }
                        tail++;
                    }
                    // Skip trailing quote char if one was there.
                    if (text[tail] === quote) {
                        tail++;
                    }
                    break;
                }
                case 'd':
                case 'D': {
                    haveContent = true;
                    // Possible start of the keyword DELIMITER. Must be at the start of the text or a character,
                    // which is not part of a regular MySQL identifier (0-9, A-Z, a-z, _, $, \u0080-\uffff).
                    const previous = tail > start ? tail - 1 : 0;
                    const isIdentifierChar = previous >= 0x80 ||
                        (text[previous] >= '0' && text[previous] <= '9') ||
                        (text[previous | 0x20] >= 'a' && text[previous | 0x20] <= 'z') ||
                        text[previous] === '$' ||
                        text[previous] === '_';
                    if (tail === start || !isIdentifierChar) {
                        let run = tail + 1;
                        let kw = keywordPos + 1;
                        let count = 9;
                        while (count-- > 1 && (run++ | 0x20) === kw++)
                            ;
                        if (count === 0 && text[run] === ' ') {
                            // Delimiter keyword found. Get the new delimiter (everything until the end of the line).
                            tail = run++;
                            while (run < end && text[run] !== lineBreak) {
                                ++run;
                            }
                            delimiter = text.substring(tail, run - tail).trim();
                            delimiterHead = delimiter;
                            // Skip over the delimiter statement and any following line breaks.
                            while (text[run] === lineBreak) {
                                ++run;
                            }
                            tail = run;
                            head = tail;
                        }
                        else {
                            ++tail;
                        }
                    }
                    else {
                        ++tail;
                    }
                    break;
                }
                default: {
                    if (text[tail] > ' ') {
                        haveContent = true;
                    }
                    tail++;
                    break;
                }
            }
            if (text[tail] === delimiterHead) {
                // Found possible start of the delimiter. Check if it really is.
                let count = delimiter.length;
                if (count === 1) {
                    // Most common case. Trim the statement and check if it is not empty before adding the range.
                    head = skip_leading_whitespace_1.skipLeadingWhitespace(text, head, tail);
                    if (head < tail) {
                        statements.push({
                            text: text.substring(head, tail),
                            start: head,
                            stop: tail
                        });
                    }
                    head = ++tail;
                    haveContent = false;
                }
                else {
                    let run = tail + 1;
                    let del = delimiterHead.length + 1;
                    while (count-- > 1 && text[run++] === text[del++])
                        ;
                    if (count === 0) {
                        // Multi char delimiter is complete. Tail still points to the start of the delimiter.
                        // Run points to the first character after the delimiter.
                        head = skip_leading_whitespace_1.skipLeadingWhitespace(text, head, tail);
                        if (head < tail) {
                            statements.push({
                                text: text.substring(head, tail),
                                start: head,
                                stop: tail
                            });
                        }
                        tail = run;
                        head = run;
                        haveContent = false;
                    }
                }
            }
        }
        // Add remaining text to the range list.
        head = skip_leading_whitespace_1.skipLeadingWhitespace(text, head, tail);
        if (head < tail) {
            statements.push({
                text: text.substring(head, tail),
                start: head,
                stop: tail
            });
        }
        return statements;
    }
    /**
     * Get the statement given by the offset.
     *
     * @param statements
     * @param offset
     * @returns Statement | null
     */
    getStatementAtOffset(statements, offset) {
        for (const statement of statements) {
            if (offset >= statement.start && offset <= statement.stop) {
                return statement;
            }
        }
        return null;
    }
    /**
     * Check if the provided text is a MySQL keyword.
     *
     * @param text
     * @returns boolean
     */
    isKeyword(text) {
        const keywords = this.getKeywords();
        return keywords.includes(text.toUpperCase());
    }
    /**
     * Check if the provided text is a MySQL reserved keyword.
     *
     * @param text
     * @returns boolean
     */
    isReservedKeyword(text) {
        const reservedKeywords = this.getReservedKeywords();
        return reservedKeywords.includes(text.toUpperCase());
    }
    /**
     * Get all MySQL keywords.
     *
     * @returns string[]
     */
    getKeywords() {
        const version = version_1.versionToNumber(this.version);
        return version_1.keywordsForVersion(version);
    }
    /**
     * Get all MySQL reserved keywords.
     *
     * @returns string[]
     */
    getReservedKeywords() {
        const version = version_1.versionToNumber(this.version);
        return version_1.reservedKeywordsForVersion(version);
    }
    /**
     * Check if the given parse result represents a DDL statement.
     *
     * @param {parseResult}
     * @returns boolean
     */
    isDDL(parseResult) {
        const queryType = this.getQueryType(parseResult);
        switch (queryType) {
            case parsers_common_1.MySQLQueryType.QtAlterDatabase:
            case parsers_common_1.MySQLQueryType.QtAlterLogFileGroup:
            case parsers_common_1.MySQLQueryType.QtAlterFunction:
            case parsers_common_1.MySQLQueryType.QtAlterProcedure:
            case parsers_common_1.MySQLQueryType.QtAlterServer:
            case parsers_common_1.MySQLQueryType.QtAlterTable:
            case parsers_common_1.MySQLQueryType.QtAlterTableSpace:
            case parsers_common_1.MySQLQueryType.QtAlterEvent:
            case parsers_common_1.MySQLQueryType.QtAlterView:
            case parsers_common_1.MySQLQueryType.QtCreateTable:
            case parsers_common_1.MySQLQueryType.QtCreateIndex:
            case parsers_common_1.MySQLQueryType.QtCreateDatabase:
            case parsers_common_1.MySQLQueryType.QtCreateEvent:
            case parsers_common_1.MySQLQueryType.QtCreateView:
            case parsers_common_1.MySQLQueryType.QtCreateRoutine:
            case parsers_common_1.MySQLQueryType.QtCreateProcedure:
            case parsers_common_1.MySQLQueryType.QtCreateFunction:
            case parsers_common_1.MySQLQueryType.QtCreateUdf:
            case parsers_common_1.MySQLQueryType.QtCreateTrigger:
            case parsers_common_1.MySQLQueryType.QtCreateLogFileGroup:
            case parsers_common_1.MySQLQueryType.QtCreateServer:
            case parsers_common_1.MySQLQueryType.QtCreateTableSpace:
            case parsers_common_1.MySQLQueryType.QtDropDatabase:
            case parsers_common_1.MySQLQueryType.QtDropEvent:
            case parsers_common_1.MySQLQueryType.QtDropFunction:
            case parsers_common_1.MySQLQueryType.QtDropProcedure:
            case parsers_common_1.MySQLQueryType.QtDropIndex:
            case parsers_common_1.MySQLQueryType.QtDropLogfileGroup:
            case parsers_common_1.MySQLQueryType.QtDropServer:
            case parsers_common_1.MySQLQueryType.QtDropTable:
            case parsers_common_1.MySQLQueryType.QtDropTablespace:
            case parsers_common_1.MySQLQueryType.QtDropTrigger:
            case parsers_common_1.MySQLQueryType.QtDropView:
            case parsers_common_1.MySQLQueryType.QtRenameTable:
            case parsers_common_1.MySQLQueryType.QtTruncateTable:
                return true;
        }
        return false;
    }
    /**
     * Get the type of query given by the parse result.
     *
     * @param {parseResult}
     * @returns MySQLQueryType
     */
    getQueryType(parseResult) {
        var _a;
        const { lexer } = parseResult;
        lexer.reset();
        let token = lexer.nextDefaultChannelToken();
        if (token.type === antlr4ts_1.Token.EOF) {
            return parsers_common_1.MySQLQueryType.QtUnknown;
        }
        switch (token.type) {
            case MySQLLexer_1.MySQLLexer.ALTER_SYMBOL:
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtAmbiguous;
                }
                switch (token.type) {
                    case MySQLLexer_1.MySQLLexer.DATABASE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtAlterDatabase;
                    case MySQLLexer_1.MySQLLexer.LOGFILE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtAlterLogFileGroup;
                    case MySQLLexer_1.MySQLLexer.FUNCTION_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtAlterFunction;
                    case MySQLLexer_1.MySQLLexer.PROCEDURE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtAlterProcedure;
                    case MySQLLexer_1.MySQLLexer.SERVER_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtAlterServer;
                    case MySQLLexer_1.MySQLLexer.TABLE_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.ONLINE_SYMBOL: // Optional part of ALTER TABLE.
                    case MySQLLexer_1.MySQLLexer.OFFLINE_SYMBOL: // ditto
                    case MySQLLexer_1.MySQLLexer.IGNORE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtAlterTable;
                    case MySQLLexer_1.MySQLLexer.TABLESPACE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtAlterTableSpace;
                    case MySQLLexer_1.MySQLLexer.EVENT_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtAlterEvent;
                    case MySQLLexer_1.MySQLLexer.VIEW_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtAlterView;
                    case MySQLLexer_1.MySQLLexer.DEFINER_SYMBOL: // TODO
                        return parsers_common_1.MySQLQueryType.QtAmbiguous;
                    case MySQLLexer_1.MySQLLexer.ALGORITHM_SYMBOL: // Optional part of CREATE VIEW.
                        return parsers_common_1.MySQLQueryType.QtAlterView;
                    case MySQLLexer_1.MySQLLexer.USER_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtAlterUser;
                }
                break;
            case MySQLLexer_1.MySQLLexer.CREATE_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtAmbiguous;
                }
                switch (token.type) {
                    case MySQLLexer_1.MySQLLexer.TEMPORARY_SYMBOL: // Optional part of CREATE TABLE.
                    case MySQLLexer_1.MySQLLexer.TABLE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateTable;
                    case MySQLLexer_1.MySQLLexer.ONLINE_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.OFFLINE_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.INDEX_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.UNIQUE_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.FULLTEXT_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.SPATIAL_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateIndex;
                    case MySQLLexer_1.MySQLLexer.DATABASE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateDatabase;
                    case MySQLLexer_1.MySQLLexer.TRIGGER_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateTrigger;
                    case MySQLLexer_1.MySQLLexer.DEFINER_SYMBOL: // TODO
                        return parsers_common_1.MySQLQueryType.QtAmbiguous;
                    case MySQLLexer_1.MySQLLexer.VIEW_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.OR_SYMBOL: // CREATE OR REPLACE ... VIEW
                    case MySQLLexer_1.MySQLLexer.ALGORITHM_SYMBOL: // CREATE ALGORITHM ... VIEW
                        return parsers_common_1.MySQLQueryType.QtCreateView;
                    case MySQLLexer_1.MySQLLexer.EVENT_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateEvent;
                    case MySQLLexer_1.MySQLLexer.FUNCTION_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateFunction;
                    case MySQLLexer_1.MySQLLexer.AGGREGATE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateUdf;
                    case MySQLLexer_1.MySQLLexer.PROCEDURE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateProcedure;
                    case MySQLLexer_1.MySQLLexer.LOGFILE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateLogFileGroup;
                    case MySQLLexer_1.MySQLLexer.SERVER_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateServer;
                    case MySQLLexer_1.MySQLLexer.TABLESPACE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateTableSpace;
                    case MySQLLexer_1.MySQLLexer.USER_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtCreateUser;
                }
                break;
            }
            case MySQLLexer_1.MySQLLexer.DROP_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtAmbiguous;
                }
                switch (token.type) {
                    case MySQLLexer_1.MySQLLexer.DATABASE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropDatabase;
                    case MySQLLexer_1.MySQLLexer.EVENT_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropEvent;
                    case MySQLLexer_1.MySQLLexer.PROCEDURE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropProcedure;
                    case MySQLLexer_1.MySQLLexer.FUNCTION_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropFunction;
                    case MySQLLexer_1.MySQLLexer.ONLINE_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.OFFLINE_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.INDEX_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropIndex;
                    case MySQLLexer_1.MySQLLexer.LOGFILE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropLogfileGroup;
                    case MySQLLexer_1.MySQLLexer.SERVER_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropServer;
                    case MySQLLexer_1.MySQLLexer.TEMPORARY_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.TABLE_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.TABLES_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropTable;
                    case MySQLLexer_1.MySQLLexer.TABLESPACE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropTablespace;
                    case MySQLLexer_1.MySQLLexer.TRIGGER_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropTrigger;
                    case MySQLLexer_1.MySQLLexer.VIEW_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropView;
                    case MySQLLexer_1.MySQLLexer.PREPARE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDeallocate;
                    case MySQLLexer_1.MySQLLexer.USER_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtDropUser;
                }
                break;
            }
            case MySQLLexer_1.MySQLLexer.TRUNCATE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtTruncateTable;
            case MySQLLexer_1.MySQLLexer.CALL_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtCall;
            case MySQLLexer_1.MySQLLexer.DELETE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtDelete;
            case MySQLLexer_1.MySQLLexer.DO_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtDo;
            case MySQLLexer_1.MySQLLexer.HANDLER_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtHandler;
            case MySQLLexer_1.MySQLLexer.INSERT_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtInsert;
            case MySQLLexer_1.MySQLLexer.LOAD_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtAmbiguous;
                }
                switch (token.type) {
                    case MySQLLexer_1.MySQLLexer.DATA_SYMBOL: {
                        token = lexer.nextDefaultChannelToken();
                        if (token.type === antlr4ts_1.Token.EOF) {
                            return parsers_common_1.MySQLQueryType.QtAmbiguous;
                        }
                        if (token.type === MySQLLexer_1.MySQLLexer.FROM_SYMBOL) {
                            return parsers_common_1.MySQLQueryType.QtLoadDataMaster;
                        }
                        return parsers_common_1.MySQLQueryType.QtLoadData;
                    }
                    case MySQLLexer_1.MySQLLexer.XML_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtLoadXML;
                    case MySQLLexer_1.MySQLLexer.TABLE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtLoadTableMaster;
                    case MySQLLexer_1.MySQLLexer.INDEX_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtLoadIndex;
                }
                break;
            }
            case MySQLLexer_1.MySQLLexer.REPLACE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtReplace;
            case MySQLLexer_1.MySQLLexer.SELECT_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtSelect;
            case MySQLLexer_1.MySQLLexer.UPDATE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtUpdate;
            case MySQLLexer_1.MySQLLexer.OPEN_PAR_SYMBOL: {
                // Either (((select ..))) or (partition...)
                while (token.type === MySQLLexer_1.MySQLLexer.OPEN_PAR_SYMBOL) {
                    token = lexer.nextDefaultChannelToken();
                    if (token.type === antlr4ts_1.Token.EOF) {
                        return parsers_common_1.MySQLQueryType.QtAmbiguous;
                    }
                }
                if (token.type === MySQLLexer_1.MySQLLexer.SELECT_SYMBOL) {
                    return parsers_common_1.MySQLQueryType.QtSelect;
                }
                return parsers_common_1.MySQLQueryType.QtPartition;
            }
            case MySQLLexer_1.MySQLLexer.PARTITION_SYMBOL:
            case MySQLLexer_1.MySQLLexer.PARTITIONS_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtPartition;
            case MySQLLexer_1.MySQLLexer.START_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtAmbiguous;
                }
                if (token.type === MySQLLexer_1.MySQLLexer.TRANSACTION_SYMBOL) {
                    return parsers_common_1.MySQLQueryType.QtStartTransaction;
                }
                return parsers_common_1.MySQLQueryType.QtStartSlave;
            }
            case MySQLLexer_1.MySQLLexer.BEGIN_SYMBOL: // Begin directly at the start of the query must be a transaction start.
                return parsers_common_1.MySQLQueryType.QtBeginWork;
            case MySQLLexer_1.MySQLLexer.COMMIT_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtCommit;
            case MySQLLexer_1.MySQLLexer.ROLLBACK_SYMBOL: {
                // We assume a transaction statement here unless we exactly know it's about a savepoint.
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtRollbackWork;
                }
                if (token.type === MySQLLexer_1.MySQLLexer.WORK_SYMBOL) {
                    token = lexer.nextDefaultChannelToken();
                    if (token.type === antlr4ts_1.Token.EOF) {
                        return parsers_common_1.MySQLQueryType.QtRollbackWork;
                    }
                }
                if (token.type === MySQLLexer_1.MySQLLexer.TO_SYMBOL) {
                    return parsers_common_1.MySQLQueryType.QtRollbackSavepoint;
                }
                return parsers_common_1.MySQLQueryType.QtRollbackWork;
            }
            case MySQLLexer_1.MySQLLexer.SET_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtSet;
                }
                switch (token.type) {
                    case MySQLLexer_1.MySQLLexer.PASSWORD_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtSetPassword;
                    case MySQLLexer_1.MySQLLexer.GLOBAL_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.LOCAL_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.SESSION_SYMBOL:
                        token = lexer.nextDefaultChannelToken();
                        if (token.type === antlr4ts_1.Token.EOF) {
                            return parsers_common_1.MySQLQueryType.QtSet;
                        }
                        break;
                    case MySQLLexer_1.MySQLLexer.IDENTIFIER: {
                        if (((_a = token.text) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'autocommit') {
                            return parsers_common_1.MySQLQueryType.QtSetAutoCommit;
                        }
                        break;
                    }
                }
                if (token.type === MySQLLexer_1.MySQLLexer.TRANSACTION_SYMBOL) {
                    return parsers_common_1.MySQLQueryType.QtSetTransaction;
                }
                return parsers_common_1.MySQLQueryType.QtSet;
            }
            case MySQLLexer_1.MySQLLexer.SAVEPOINT_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtSavepoint;
            case MySQLLexer_1.MySQLLexer.RELEASE_SYMBOL: // Release at the start of the query, obviously.
                return parsers_common_1.MySQLQueryType.QtReleaseSavepoint;
            case MySQLLexer_1.MySQLLexer.LOCK_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtLock;
            case MySQLLexer_1.MySQLLexer.UNLOCK_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtUnlock;
            case MySQLLexer_1.MySQLLexer.XA_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtXA;
            case MySQLLexer_1.MySQLLexer.PURGE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtPurge;
            case MySQLLexer_1.MySQLLexer.CHANGE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtChangeMaster;
            case MySQLLexer_1.MySQLLexer.RESET_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtReset;
                }
                switch (token.type) {
                    case MySQLLexer_1.MySQLLexer.SERVER_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtResetMaster;
                    case MySQLLexer_1.MySQLLexer.SLAVE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtResetSlave;
                    default:
                        return parsers_common_1.MySQLQueryType.QtReset;
                }
            }
            case MySQLLexer_1.MySQLLexer.STOP_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtStopSlave;
            case MySQLLexer_1.MySQLLexer.PREPARE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtPrepare;
            case MySQLLexer_1.MySQLLexer.EXECUTE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtExecute;
            case MySQLLexer_1.MySQLLexer.DEALLOCATE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtDeallocate;
            case MySQLLexer_1.MySQLLexer.GRANT_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtAmbiguous;
                }
                if (token.type === MySQLLexer_1.MySQLLexer.PROXY_SYMBOL) {
                    return parsers_common_1.MySQLQueryType.QtGrantProxy;
                }
                return parsers_common_1.MySQLQueryType.QtGrant;
            }
            case MySQLLexer_1.MySQLLexer.RENAME_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtAmbiguous;
                }
                if (token.type === MySQLLexer_1.MySQLLexer.USER_SYMBOL) {
                    return parsers_common_1.MySQLQueryType.QtRenameUser;
                }
                return parsers_common_1.MySQLQueryType.QtRenameTable;
            }
            case MySQLLexer_1.MySQLLexer.REVOKE_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtAmbiguous;
                }
                if (token.type === MySQLLexer_1.MySQLLexer.PROXY_SYMBOL) {
                    return parsers_common_1.MySQLQueryType.QtRevokeProxy;
                }
                return parsers_common_1.MySQLQueryType.QtRevoke;
            }
            case MySQLLexer_1.MySQLLexer.ANALYZE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtAnalyzeTable;
            case MySQLLexer_1.MySQLLexer.CHECK_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtCheckTable;
            case MySQLLexer_1.MySQLLexer.CHECKSUM_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtChecksumTable;
            case MySQLLexer_1.MySQLLexer.OPTIMIZE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtOptimizeTable;
            case MySQLLexer_1.MySQLLexer.REPAIR_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtRepairTable;
            case MySQLLexer_1.MySQLLexer.BACKUP_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtBackUpTable;
            case MySQLLexer_1.MySQLLexer.RESTORE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtRestoreTable;
            case MySQLLexer_1.MySQLLexer.INSTALL_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtInstallPlugin;
            case MySQLLexer_1.MySQLLexer.UNINSTALL_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtUninstallPlugin;
            case MySQLLexer_1.MySQLLexer.SHOW_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtShow;
                }
                if (token.type === MySQLLexer_1.MySQLLexer.FULL_SYMBOL) {
                    // Not all SHOW cases allow an optional FULL keyword, but this is not about checking for
                    // a valid query but to find the most likely type.
                    token = lexer.nextDefaultChannelToken();
                    if (token.type === antlr4ts_1.Token.EOF) {
                        return parsers_common_1.MySQLQueryType.QtShow;
                    }
                }
                switch (token.type) {
                    case MySQLLexer_1.MySQLLexer.GLOBAL_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.LOCK_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.SESSION_SYMBOL: {
                        token = lexer.nextDefaultChannelToken();
                        if (token.type === antlr4ts_1.Token.EOF) {
                            return parsers_common_1.MySQLQueryType.QtShow;
                        }
                        if (token.type === MySQLLexer_1.MySQLLexer.STATUS_SYMBOL) {
                            return parsers_common_1.MySQLQueryType.QtShowStatus;
                        }
                        return parsers_common_1.MySQLQueryType.QtShowVariables;
                    }
                    case MySQLLexer_1.MySQLLexer.AUTHORS_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowAuthors;
                    case MySQLLexer_1.MySQLLexer.BINARY_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowBinaryLogs;
                    case MySQLLexer_1.MySQLLexer.BINLOG_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowBinlogEvents;
                    case MySQLLexer_1.MySQLLexer.RELAYLOG_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowRelaylogEvents;
                    case MySQLLexer_1.MySQLLexer.CHAR_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowCharset;
                    case MySQLLexer_1.MySQLLexer.COLLATION_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowCollation;
                    case MySQLLexer_1.MySQLLexer.COLUMNS_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowColumns;
                    case MySQLLexer_1.MySQLLexer.CONTRIBUTORS_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowContributors;
                    case MySQLLexer_1.MySQLLexer.COUNT_SYMBOL: {
                        token = lexer.nextDefaultChannelToken();
                        if (token.type != MySQLLexer_1.MySQLLexer.OPEN_PAR_SYMBOL) {
                            return parsers_common_1.MySQLQueryType.QtShow;
                        }
                        token = lexer.nextDefaultChannelToken();
                        if (token.type != MySQLLexer_1.MySQLLexer.MULT_OPERATOR) {
                            return parsers_common_1.MySQLQueryType.QtShow;
                        }
                        token = lexer.nextDefaultChannelToken();
                        if (token.type != MySQLLexer_1.MySQLLexer.CLOSE_PAR_SYMBOL) {
                            return parsers_common_1.MySQLQueryType.QtShow;
                        }
                        token = lexer.nextDefaultChannelToken();
                        if (token.type === antlr4ts_1.Token.EOF) {
                            return parsers_common_1.MySQLQueryType.QtShow;
                        }
                        switch (token.type) {
                            case MySQLLexer_1.MySQLLexer.WARNINGS_SYMBOL:
                                return parsers_common_1.MySQLQueryType.QtShowWarnings;
                            case MySQLLexer_1.MySQLLexer.ERRORS_SYMBOL:
                                return parsers_common_1.MySQLQueryType.QtShowErrors;
                        }
                        return parsers_common_1.MySQLQueryType.QtShow;
                    }
                    case MySQLLexer_1.MySQLLexer.CREATE_SYMBOL: {
                        token = lexer.nextDefaultChannelToken();
                        if (token.type === antlr4ts_1.Token.EOF) {
                            return parsers_common_1.MySQLQueryType.QtShow;
                        }
                        switch (token.type) {
                            case MySQLLexer_1.MySQLLexer.DATABASE_SYMBOL:
                                return parsers_common_1.MySQLQueryType.QtShowCreateDatabase;
                            case MySQLLexer_1.MySQLLexer.EVENT_SYMBOL:
                                return parsers_common_1.MySQLQueryType.QtShowCreateEvent;
                            case MySQLLexer_1.MySQLLexer.FUNCTION_SYMBOL:
                                return parsers_common_1.MySQLQueryType.QtShowCreateFunction;
                            case MySQLLexer_1.MySQLLexer.PROCEDURE_SYMBOL:
                                return parsers_common_1.MySQLQueryType.QtShowCreateProcedure;
                            case MySQLLexer_1.MySQLLexer.TABLE_SYMBOL:
                                return parsers_common_1.MySQLQueryType.QtShowCreateTable;
                            case MySQLLexer_1.MySQLLexer.TRIGGER_SYMBOL:
                                return parsers_common_1.MySQLQueryType.QtShowCreateTrigger;
                            case MySQLLexer_1.MySQLLexer.VIEW_SYMBOL:
                                return parsers_common_1.MySQLQueryType.QtShowCreateView;
                        }
                        return parsers_common_1.MySQLQueryType.QtShow;
                    }
                    case MySQLLexer_1.MySQLLexer.DATABASES_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowDatabases;
                    case MySQLLexer_1.MySQLLexer.ENGINE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowEngineStatus;
                    case MySQLLexer_1.MySQLLexer.STORAGE_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.ENGINES_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowStorageEngines;
                    case MySQLLexer_1.MySQLLexer.ERRORS_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowErrors;
                    case MySQLLexer_1.MySQLLexer.EVENTS_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowEvents;
                    case MySQLLexer_1.MySQLLexer.FUNCTION_SYMBOL: {
                        token = lexer.nextDefaultChannelToken();
                        if (token.type === antlr4ts_1.Token.EOF) {
                            return parsers_common_1.MySQLQueryType.QtAmbiguous;
                        }
                        if (token.type === MySQLLexer_1.MySQLLexer.CODE_SYMBOL) {
                            return parsers_common_1.MySQLQueryType.QtShowFunctionCode;
                        }
                        return parsers_common_1.MySQLQueryType.QtShowFunctionStatus;
                    }
                    case MySQLLexer_1.MySQLLexer.GRANT_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowGrants;
                    case MySQLLexer_1.MySQLLexer.INDEX_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.INDEXES_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.KEY_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowIndexes;
                    case MySQLLexer_1.MySQLLexer.INNODB_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowInnoDBStatus;
                    case MySQLLexer_1.MySQLLexer.MASTER_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowMasterStatus;
                    case MySQLLexer_1.MySQLLexer.OPEN_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowOpenTables;
                    case MySQLLexer_1.MySQLLexer.PLUGIN_SYMBOL:
                    case MySQLLexer_1.MySQLLexer.PLUGINS_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowPlugins;
                    case MySQLLexer_1.MySQLLexer.PROCEDURE_SYMBOL: {
                        token = lexer.nextDefaultChannelToken();
                        if (token.type === antlr4ts_1.Token.EOF) {
                            return parsers_common_1.MySQLQueryType.QtShow;
                        }
                        if (token.type === MySQLLexer_1.MySQLLexer.STATUS_SYMBOL) {
                            return parsers_common_1.MySQLQueryType.QtShowProcedureStatus;
                        }
                        return parsers_common_1.MySQLQueryType.QtShowProcedureCode;
                    }
                    case MySQLLexer_1.MySQLLexer.PRIVILEGES_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowPrivileges;
                    case MySQLLexer_1.MySQLLexer.PROCESSLIST_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowProcessList;
                    case MySQLLexer_1.MySQLLexer.PROFILE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowProfile;
                    case MySQLLexer_1.MySQLLexer.PROFILES_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowProfiles;
                    case MySQLLexer_1.MySQLLexer.SLAVE_SYMBOL: {
                        token = lexer.nextDefaultChannelToken();
                        if (token.type === antlr4ts_1.Token.EOF) {
                            return parsers_common_1.MySQLQueryType.QtAmbiguous;
                        }
                        if (token.type === MySQLLexer_1.MySQLLexer.HOSTS_SYMBOL) {
                            return parsers_common_1.MySQLQueryType.QtShowSlaveHosts;
                        }
                        return parsers_common_1.MySQLQueryType.QtShowSlaveStatus;
                    }
                    case MySQLLexer_1.MySQLLexer.STATUS_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowStatus;
                    case MySQLLexer_1.MySQLLexer.VARIABLES_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowVariables;
                    case MySQLLexer_1.MySQLLexer.TABLE_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowTableStatus;
                    case MySQLLexer_1.MySQLLexer.TABLES_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowTables;
                    case MySQLLexer_1.MySQLLexer.TRIGGERS_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowTriggers;
                    case MySQLLexer_1.MySQLLexer.WARNINGS_SYMBOL:
                        return parsers_common_1.MySQLQueryType.QtShowWarnings;
                }
                return parsers_common_1.MySQLQueryType.QtShow;
            }
            case MySQLLexer_1.MySQLLexer.CACHE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtCacheIndex;
            case MySQLLexer_1.MySQLLexer.FLUSH_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtFlush;
            case MySQLLexer_1.MySQLLexer.KILL_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtKill;
            case MySQLLexer_1.MySQLLexer.DESCRIBE_SYMBOL: // EXPLAIN is converted to DESCRIBE in the lexer.
            case MySQLLexer_1.MySQLLexer.DESC_SYMBOL: {
                token = lexer.nextDefaultChannelToken();
                if (token.type === antlr4ts_1.Token.EOF) {
                    return parsers_common_1.MySQLQueryType.QtAmbiguous;
                }
                if (this.isIdentifier(parseResult, token.type) || token.type === MySQLLexer_1.MySQLLexer.DOT_SYMBOL) {
                    return parsers_common_1.MySQLQueryType.QtExplainTable;
                }
                // EXTENDED is a bit special as it can be both, a table identifier or the keyword.
                if (token.type === MySQLLexer_1.MySQLLexer.EXTENDED_SYMBOL) {
                    token = lexer.nextDefaultChannelToken();
                    if (token.type === antlr4ts_1.Token.EOF) {
                        return parsers_common_1.MySQLQueryType.QtExplainTable;
                    }
                    switch (token.type) {
                        case MySQLLexer_1.MySQLLexer.DELETE_SYMBOL:
                        case MySQLLexer_1.MySQLLexer.INSERT_SYMBOL:
                        case MySQLLexer_1.MySQLLexer.REPLACE_SYMBOL:
                        case MySQLLexer_1.MySQLLexer.UPDATE_SYMBOL:
                            return parsers_common_1.MySQLQueryType.QtExplainStatement;
                        default:
                            return parsers_common_1.MySQLQueryType.QtExplainTable;
                    }
                }
                return parsers_common_1.MySQLQueryType.QtExplainStatement;
            }
            case MySQLLexer_1.MySQLLexer.HELP_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtHelp;
            case MySQLLexer_1.MySQLLexer.USE_SYMBOL:
                return parsers_common_1.MySQLQueryType.QtUse;
        }
        return parsers_common_1.MySQLQueryType.QtUnknown;
    }
    /**
     * Check if the given `type` represents an identifier.
     *
     * @param {parseResult}
     * @param {type}
     * @returns boolean
     */
    isIdentifier(parseResult, type) {
        if (type === MySQLLexer_1.MySQLLexer.IDENTIFIER || type === MySQLLexer_1.MySQLLexer.BACK_TICK_QUOTED_ID) {
            return true;
        }
        const symbol = parseResult.lexer.vocabulary.getSymbolicName(type);
        if (symbol && !this.isReservedKeyword(symbol)) {
            return true;
        }
        return false;
    }
}
exports.default = Parser;
//# sourceMappingURL=parser.js.map